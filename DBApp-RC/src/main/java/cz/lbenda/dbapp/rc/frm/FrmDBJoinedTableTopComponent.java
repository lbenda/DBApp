/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package cz.lbenda.dbapp.rc.frm;

import cz.lbenda.dbapp.rc.db.Column;
import cz.lbenda.dbapp.rc.db.DbStructureReader;
import cz.lbenda.dbapp.rc.db.TableDescription;
import java.awt.BorderLayout;
import java.beans.IntrospectionException;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;

import cz.lbenda.dbapp.rc.frm.gui.ColumnCellRenderer;
import org.netbeans.api.settings.ConvertAsProperties;
import org.openide.awt.ActionID;
import org.openide.awt.ActionReference;
import org.openide.explorer.ExplorerManager;
import org.openide.explorer.view.OutlineView;
import org.openide.nodes.AbstractNode;
import org.openide.nodes.ChildFactory;
import org.openide.nodes.Children;
import org.openide.nodes.Node;
import org.openide.util.Exceptions;
import org.openide.util.NbBundle.Messages;
import org.openide.util.lookup.AbstractLookup;
import org.openide.util.lookup.InstanceContent;
import org.openide.windows.TopComponent;

import javax.swing.*;

/**
 * Top component which displays something.
 */
@ConvertAsProperties(
        dtd = "-//cz.lbenda.dbapp.rc.frm//FrmDBJoinedTable//EN",
        autostore = false
)
@TopComponent.Description(
        preferredID = "FrmDBJoinedTableTopComponent",
        iconBase = "cz/lbenda/dbapp/rc/frm/join_indexes.png",
        persistenceType = TopComponent.PERSISTENCE_ALWAYS
)
@TopComponent.Registration(mode = "output", openAtStartup = true)//mode = "bottomSlidingSide", openAtStartup = false)
@ActionID(category = "Window", id = "cz.lbenda.dbapp.rc.frm.FrmDBJoinedTableTopComponent")
@ActionReference(path = "Menu/Window" /*, position = 333 */)
@TopComponent.OpenActionRegistration(
        displayName = "#CTL_FrmDBJoinedTableAction",
        preferredID = "FrmDBJoinedTableTopComponent"
)
@Messages({
  "CTL_FrmDBJoinedTableAction=Spojené tabulky",
  "CTL_FrmDBJoinedTableTopComponent=Spojené tabulky",
  "HINT_FrmDBJoinedTableTopComponent=Okno se spojenými tabulkami"
})
public final class FrmDBJoinedTableTopComponent extends TopComponent implements ExplorerManager.Provider, ChosenTable.ChosenTableListener {

  private static final Logger LOG = Logger.getLogger(FrmDbStructureTopComponent.class.getName());
  private final OutlineView ov;
  private final ExplorerManager em = new ExplorerManager();
  private final InstanceContent ic = new InstanceContent();

  public FrmDBJoinedTableTopComponent() {
    initComponents();
    ChosenTable.getInstance().addTableListener(this);
    setName(Bundle.CTL_FrmDBJoinedTableTopComponent());
    setToolTipText(Bundle.HINT_FrmDBJoinedTableTopComponent());

    setLayout(new BorderLayout());
    ov = new OutlineView();
    ov.getOutline().setRootVisible(false);
    ov.getOutline().setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
    add(ov, BorderLayout.CENTER);

    Node rootNode = new AbstractNode(Children.create(new JoinedTableChildFactory(), true));
    em.setRootContext(rootNode);

    ic.add(em);
    ic.add(getActionMap());
    associateLookup(new AbstractLookup(ic));
  }

  @Override
  public ExplorerManager getExplorerManager() {
    return em;
  }

  /**
   * This method is called from within the constructor to initialize the form. WARNING: Do NOT
   * modify this code. The content of this method is always regenerated by the Form Editor.
   */
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {

    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
    this.setLayout(layout);
    layout.setHorizontalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGap(0, 400, Short.MAX_VALUE)
    );
    layout.setVerticalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGap(0, 300, Short.MAX_VALUE)
    );
  }// </editor-fold>//GEN-END:initComponents

  // Variables declaration - do not modify//GEN-BEGIN:variables
  // End of variables declaration//GEN-END:variables
  @Override
  public void componentOpened() {
    // TODO add custom code on component opening
  }

  @Override
  public void componentClosed() {
    // TODO add custom code on component closing
  }

  void writeProperties(java.util.Properties p) {
    // better to version settings since initial version as advocated at
    // http://wiki.apidesign.org/wiki/PropertyFiles
    p.setProperty("version", "1.0");
    // TODO store your settings
  }

  void readProperties(java.util.Properties p) {
    String version = p.getProperty("version");
    // TODO read your settings according to their version
  }

  @Override
  public void tableChosen(TableDescription tableDescription) {
    LOG.log(Level.INFO, "Table chosen");
    LinkedHashSet<String> columnNames = new LinkedHashSet<>();
    List<Column> columns = new ArrayList<>();
    Map<String, String> descriptions = new HashMap<>();
    for (DbStructureReader.ForeignKey key : tableDescription.getForeignKeys()) {
      if (key.getMasterColumn().getExtensions().isEmpty()) { // FIXME only combo box is ignored
        final TableDescription td;
        final Column skipColumn;
        if (key.getMasterTable().equals(tableDescription)) {
          td = key.getSlaveTable();
          skipColumn = key.getSlaveColumn();
        } else {
          td = key.getMasterTable();
          skipColumn = key.getMasterColumn();
        }
        for (Column col : td.getColumns()) {
          if (col.getComment() != null && !"".equals(col.getComment().trim())) {
            if (descriptions.containsKey(col.getName())) {
              descriptions.put(col.getName(),
                  descriptions.get(col.getName()) + "; " + col.getTableDescription().getName() + ": " + col.getComment());
            } else {
              descriptions.put(col.getName(), col.getTableDescription().getName() + ": " + col.getComment());
            }
          }
          if (!col.equals(skipColumn) && !columnNames.contains(col.getName())) {
            columnNames.add(col.getName());
            columns.add(col);
            LOG.log(Level.INFO, "Column for show: " + col.getName());
          }
        }
      }
    }
    String[] cols = new String[columnNames.size() * 2];
    int i = 0;
    for (String col : columnNames) {
      cols[i] = col;
      i++;
      cols[i] = col;
      i++;
    }
    ov.getOutline().setDefaultRenderer(Node.Property.class, new ColumnCellRenderer(columns));
    ov.setPropertyColumns(cols);


    for (Map.Entry<String, String> entry : descriptions.entrySet()) {
      ov.setPropertyColumnDescription(entry.getKey(), entry.getValue());
    }
  }

  public static class JoinedTableChildFactory extends ChildFactory<DbStructureReader.ForeignKey> implements ChosenTable.ChosenTableListener {
    /** Master table */
    private TableDescription masterTD;
    public JoinedTableChildFactory() {
      ChosenTable.getInstance().addTableListener(this);
    }
    @Override
    protected boolean createKeys(List<DbStructureReader.ForeignKey> toPopulate) {
      if (masterTD == null) { return true; }
      for (DbStructureReader.ForeignKey key : masterTD.getForeignKeys()) {
        final Column col;
        if (masterTD.equals(key.getMasterTable())) { col = key.getMasterColumn(); }
        else { col = key.getSlaveColumn(); }
        if (col.getExtensions().isEmpty()) { // FIXME only combo box is ignored
          toPopulate.add(key);
        }
      }
      return true;
    }
    @Override
    protected Node createNodeForKey(DbStructureReader.ForeignKey key) {
      AbstractNode node = new AbstractNode(Children.create(new JoinedRowChildFactory(masterTD, key), true));
      if (key.getMasterTable().equals(masterTD)) { node.setName(key.getSlaveTable().getName() + " > " + key.getMasterColumn().getName()); }
      else { node.setName(key.getMasterTable().getName() + " > " + key.getSlaveColumn().getName()); }
      return node;
    }

    @Override
    public void tableChosen(TableDescription tableDescription) {
      if (!tableDescription.equals(masterTD)) {
        masterTD = tableDescription;
        refresh(true);
      }
    }
  }

  public static class JoinedRowChildFactory extends ChildFactory<RowNode.Row> implements ChosenTable.ChosenRowListener {
    /** Master table */
    private TableDescription masterTD;
    private final DbStructureReader.ForeignKey fKey;
    private RowNode.Row masterRow;
    public JoinedRowChildFactory(TableDescription masterTD, DbStructureReader.ForeignKey fKey) {
      this.masterTD = masterTD;
      this.fKey = fKey;
      ChosenTable.getInstance().addRowListener(this);
    }
    @Override
    protected boolean createKeys(List<RowNode.Row> toPopulate) {
      if (masterRow == null) { return true; }
      toPopulate.addAll(masterTD.getSessionConfiguration().getReader().getJoinedRows(fKey, masterRow));
      return true;
    }
    @Override
    protected Node createNodeForKey(RowNode.Row key) {
      RowNode node = null;
      try {
        node = new RowNode(key);
      } catch (IntrospectionException ex) {
        LOG.log(Level.SEVERE, "Faild to create node.", ex);
        Exceptions.printStackTrace(ex);
      }
      return node;
    }
    @Override
    public void rowChosen(TableDescription td, RowNode.Row selectedRowValues) {
      masterTD = td;
      masterRow = selectedRowValues;
      refresh(true);
    }
  }
}
