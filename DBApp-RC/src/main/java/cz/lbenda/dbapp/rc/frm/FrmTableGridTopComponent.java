/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package cz.lbenda.dbapp.rc.frm;

import com.toedter.calendar.JDateChooserCellEditor;
import cz.lbenda.dbapp.rc.AbstractHelper;
import cz.lbenda.dbapp.rc.db.DbStructureReader;
import cz.lbenda.dbapp.rc.db.DbStructureReader.Column;
import cz.lbenda.dbapp.rc.db.TableDescription;
import cz.lbenda.dbapp.rc.frm.ChosenTable.ChosenTableListener;
import cz.lbenda.dbapp.rc.frm.ChosenTable.RowUpdateListener;
import org.netbeans.api.settings.ConvertAsProperties;
import org.openide.awt.ActionID;
import org.openide.awt.ActionReference;
import org.openide.util.NbBundle.Messages;
import org.openide.windows.TopComponent;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.swing.*;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import javax.swing.event.TableModelEvent;
import javax.swing.event.TableModelListener;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.TableCellEditor;
import javax.swing.table.TableColumn;
import java.awt.*;
import java.util.*;
import java.util.List;

/**
 * Top component which displays something.
 */
@ConvertAsProperties(
        dtd = "-//cz.lbenda.applicationdb.rc.frm//FrmTableGrid//EN",
        autostore = false
)
@TopComponent.Description(
        preferredID = "FrmTableGridTopComponent",
        //iconBase="SET/PATH/TO/ICON/HERE",
        persistenceType = TopComponent.PERSISTENCE_ALWAYS
)
@TopComponent.Registration(mode = "editor", openAtStartup = true)
@ActionID(category = "Window", id = "cz.lbenda.applicationdb.rc.frm.FrmTableGridTopComponent")
@ActionReference(path = "Menu/Window" /*, position = 333 */)
@TopComponent.OpenActionRegistration(
        displayName = "#CTL_FrmTableGridAction",
        preferredID = "FrmTableGridTopComponent"
)
@Messages({
  "CTL_FrmTableGridAction=FrmTableGrid",
  // "CTL_FrmTableGridTopComponent",
  // "HINT_FrmTableGridTopComponent"
  "CTL_FrmTableGridTopComponent=Tabulka",
  "HINT_FrmTableGridTopComponent=This is a FrmTableGrid window"
})
public final class FrmTableGridTopComponent extends TopComponent implements ChosenTableListener {

  private static final Logger LOG = LoggerFactory.getLogger(FrmTableGridTopComponent.class);

  private static RSTableModel tableModel;

  public FrmTableGridTopComponent() {
    initComponents();
    setName(Bundle.CTL_FrmTableGridTopComponent());
    setToolTipText(Bundle.HINT_FrmTableGridTopComponent());
  }

  /**
   * This method is called from within the constructor to initialize the form. WARNING: Do NOT
   * modify this code. The content of this method is always regenerated by the Form Editor.
   */
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {

    jScrollPane1 = new javax.swing.JScrollPane();
    jTable1 = new javax.swing.JTable();
    jToolBar1 = new javax.swing.JToolBar();
    bSave = new javax.swing.JButton();
    bInsert = new javax.swing.JButton();
    bCancel = new javax.swing.JButton();
    bRemove = new javax.swing.JButton();

    jTable1.setModel(new javax.swing.table.DefaultTableModel(
      new Object [][] {
        {},
        {},
        {},
        {}
      },
      new String [] {

      }
    ));
    jTable1.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_OFF);
    jScrollPane1.setViewportView(jTable1);

    jToolBar1.setRollover(true);

    org.openide.awt.Mnemonics.setLocalizedText(bSave, org.openide.util.NbBundle.getMessage(FrmTableGridTopComponent.class, "FrmTableGridTopComponent.bSave.text")); // NOI18N
    bSave.setFocusable(false);
    bSave.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
    bSave.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
    bSave.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        bSaveActionPerformed(evt);
      }
    });
    jToolBar1.add(bSave);

    org.openide.awt.Mnemonics.setLocalizedText(bInsert, org.openide.util.NbBundle.getMessage(FrmTableGridTopComponent.class, "FrmTableGridTopComponent.bInsert.text")); // NOI18N
    bInsert.setFocusable(false);
    bInsert.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
    bInsert.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
    bInsert.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        bInsertActionPerformed(evt);
      }
    });
    jToolBar1.add(bInsert);

    org.openide.awt.Mnemonics.setLocalizedText(bCancel, org.openide.util.NbBundle.getMessage(FrmTableGridTopComponent.class, "FrmTableGridTopComponent.bCancel.text")); // NOI18N
    bCancel.setFocusable(false);
    bCancel.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
    bCancel.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
    bCancel.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        bCancelActionPerformed(evt);
      }
    });
    jToolBar1.add(bCancel);

    org.openide.awt.Mnemonics.setLocalizedText(bRemove, org.openide.util.NbBundle.getMessage(FrmTableGridTopComponent.class, "FrmTableGridTopComponent.bRemove.text")); // NOI18N
    bRemove.setFocusable(false);
    bRemove.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
    bRemove.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
    bRemove.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        bRemoveActionPerformed(evt);
      }
    });
    jToolBar1.add(bRemove);

    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
    this.setLayout(layout);
    layout.setHorizontalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addComponent(jToolBar1, javax.swing.GroupLayout.DEFAULT_SIZE, 330, Short.MAX_VALUE)
      .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
    );
    layout.setVerticalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
        .addComponent(jToolBar1, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 223, Short.MAX_VALUE))
    );
  }// </editor-fold>//GEN-END:initComponents

  private void bInsertActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bInsertActionPerformed
    tableModel.newRow();
  }//GEN-LAST:event_bInsertActionPerformed

  private void bCancelActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bCancelActionPerformed
    tableModel.cancel();
  }//GEN-LAST:event_bCancelActionPerformed

  private void bRemoveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bRemoveActionPerformed
    tableModel.removeSelected();
  }//GEN-LAST:event_bRemoveActionPerformed

  private void bSaveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bSaveActionPerformed
    tableModel.save();
  }//GEN-LAST:event_bSaveActionPerformed

  // Variables declaration - do not modify//GEN-BEGIN:variables
  private javax.swing.JButton bCancel;
  private javax.swing.JButton bInsert;
  private javax.swing.JButton bRemove;
  private javax.swing.JButton bSave;
  private javax.swing.JScrollPane jScrollPane1;
  private javax.swing.JTable jTable1;
  private javax.swing.JToolBar jToolBar1;
  // End of variables declaration//GEN-END:variables

  TableModelListener tableModelListener = new TableModelListener() {
    @Override
    public void tableChanged(final TableModelEvent e) {
      if (TableModelEvent.INSERT == e.getType()) {
        SwingUtilities.invokeLater(new Runnable() {
          public void run() {
            jTable1.setRowSelectionInterval(e.getFirstRow(), e.getLastRow());
            for (Column col : td.getColumns()) {
              if (!col.isAutoincrement() && !col.isGenerated()) {
                jTable1.setColumnSelectionInterval(col.getPosition(), col.getPosition());
                jTable1.scrollRectToVisible(new Rectangle(jTable1.getCellRect(e.getFirstRow(),
                        col.getPosition(), true)));
                jTable1.editCellAt(e.getFirstRow(), col.getPosition());
                break;
              }
            }
          }
        });
      }
    }
  };

  @Override
  public void componentOpened() {
    ChosenTable.getInstance().addTableListener(this);

    jTable1.getSelectionModel().addListSelectionListener(new ListSelectionListener() {
      @Override
      public void valueChanged(ListSelectionEvent e) {
        rowSelected();
      }
    });
  }

  /** Method which is called when new row i selected */
  private void rowSelected() {
    int selRow = jTable1.getSelectedRow();
    if(selRow != -1) {
      Map<Column, Object> values = new HashMap<>(tableModel.getColumnCount());
      for (int i = 0; i < tableModel.getColumnCount(); i++) {
        values.put(this.td.getColumns().get(i), tableModel.getValueAt(selRow, i));
      }
      ChosenTable.getInstance().setSelectedRowValues(values);
    }
  }

  @Override
  public void componentClosed() {
    // TODO add custom code on component closing
  }

  void writeProperties(java.util.Properties p) {
    // better to version settings since initial version as advocated at
    // http://wiki.apidesign.org/wiki/PropertyFiles
    p.setProperty("version", "1.0");
    // TODO store your settings
  }

  void readProperties(java.util.Properties p) {
    String version = p.getProperty("version");
    // TODO read your settings according to their version
  }

  private TableDescription td;

  @Override
  public void tableChosen(TableDescription tableDescription) {
    this.td = tableDescription;
    this.bSave.setEnabled(false);
    if (tableModel != null) { ChosenTable.getInstance().removeRowUpdateListener(tableModel); }
    tableModel = new RSTableModel(tableDescription);
    jTable1.setModel(tableModel);
    ChosenTable.getInstance().addRowUpdateListener(tableModel);
    jTable1.setDefaultRenderer(Object.class, new CustomRenderer(td));
    jTable1.setDefaultRenderer(Integer.class, new CustomRenderer(td));
    jTable1.setDefaultRenderer(Integer.TYPE, new CustomRenderer(td));
    tableModel.addTableModelListener(tableModelListener);
    setCellEditors(td);
  }

  private void setCellEditors(TableDescription td) {
    for (Column col : td.getColumns()) {
      if (jTable1.getColumnCount() <= col.getPosition()) {
        LOG.error("Something wierd, the jTable have less column then col in table: " + td.getName() + " "+ jTable1.getColumnCount());
      } else{
        TableColumn column = jTable1.getColumnModel().getColumn(col.getPosition());
        column.setCellEditor(createEditor(col));
      }
    }
  }

  private TableCellEditor createEditor(Column col) {
    switch (col.getDataType()) {
      case DATE : return new JDateChooserCellEditor();
      default :
        JTextField jf = new JTextField();
        return new DefaultCellEditor(jf);
    }
  }

  private class RSTableModel extends AbstractTableModel implements RowUpdateListener {

    private final List<Object[]> rows = new ArrayList<>();
    /** Map which contains old values of field. First index is row, second is column. */
    private final Map<Integer, Map<Integer, Object>> oldRows = new HashMap<>();
    /** Set of all new added records */
    private final Set<Object[]> newRows = new LinkedHashSet<>();
    /** Removed rows. Integer is place where will be insert row when cancel funciton is executed. */
    private final Map<Integer, Object[]> deletedRows = new HashMap<>();
    private final TableDescription td;

    private RSTableModel(TableDescription td) {
      this.td = td;
      rows.addAll(DbStructureReader.getInstance().readTableDate(td, -1, 0));
    }

    @Override
    public void rowUpdated(TableDescription td, Map<Column, Object> oldValues, Map<Column, Object> newValues) {
      if (td.equals(this.td)) {
        if (oldValues == null || oldValues.isEmpty()) {
          Object[] row = new Object[td.getColumns().size()];
          for (Column col : td.getColumns()) {
            row[col.getPosition()] = newValues.get(col);
          }
          this.rows.add(row);
          this.fireTableRowsInserted(rows.size() - 1, rows.size() - 1);
        } else {
          int i = 0;
          for (Object[] row : rows) {
            boolean skip = false;
            for (Column col : td.getPKColumns()) {
              Object v = oldValues.get(col);
              Object rv = row[col.getPosition()];
              if ((v == null && rv != null) || (v != null && (!v.equals(rv)))) {
                skip = true;
                break;
              }
            }
            if (!skip) { break; }
            else { i++; }
          }
          Object row [] = rows.get(i);
          for (Column col : td.getColumns()) { row[col.getPosition()] = newValues.get(col); }
          this.fireTableRowsUpdated(i, i);
        }
      }
    }

    @Override
    public String getColumnName(int column) {
      return td.getColumns().get(column).toString();
    }

    /** Method witch add new row */
    public void newRow() {
      Object[] newRow = new Object[td.getColumns().size()];
      rows.add(newRow);
      newRows.add(newRow);
      this.fireTableRowsInserted(rows.size() - 1, rows.size() - 1);

      saveEnabled();
    }

    /** Method which save all changes in table */
    public void save() {
      for (Map.Entry<Integer, Map<Integer, Object>> rowM : oldRows.entrySet()) {
        Map<Column, Object> oldRow = new HashMap<>();
        Map<Column, Object> newRow = new HashMap<>();
        Object[] row = rows.get(rowM.getKey());
        for (Column col : td.getColumns()) {
          newRow.put(col, row[col.getPosition()]);
        }
        oldRow.putAll(newRow);
        for (Map.Entry<Integer, Object> entry : rowM.getValue().entrySet()) {
          oldRow.put(td.getColumns().get(entry.getKey()), entry.getValue());
        }
        DbStructureReader.getInstance().updateRow(td, oldRow, newRow);
      }
      oldRows.clear();

      for (Object[] row : newRows) {
        Map<Column, Object> newRow = new HashMap<>();
        for (Column col : td.getColumns()) { newRow.put(col, row[col.getPosition()]); }
        DbStructureReader.getInstance().insertRow(td, newRow);
      }
      newRows.clear();

      for (Object[] row : deletedRows.values()) {
        Map<Column, Object> delRow = new HashMap<>();
        for (Column col : td.getColumns()) { delRow.put(col, row[col.getPosition()]); }
        DbStructureReader.getInstance().deleteRow(td, delRow);
      }
      deletedRows.clear();

      saveEnabled();
    }

    /** Method which remove all selected rows
     * The remove selected function find already deleted row and calculate rows of new deleted record
     * as nothing was deleted.
     */
    public void removeSelected() {
      List<Integer> alreadyDeletdRows = new ArrayList(deletedRows.keySet());
      Collections.sort(alreadyDeletdRows);

      for (int selectedRow : jTable1.getSelectedRows()) {
        final int add;
        if (!alreadyDeletdRows.isEmpty()) {
          if (alreadyDeletdRows.contains(Integer.valueOf(selectedRow))) {
            add = alreadyDeletdRows.indexOf(Integer.valueOf(selectedRow)) + 1;
          } else {
            alreadyDeletdRows.add(Integer.valueOf(selectedRow));
            Collections.sort(alreadyDeletdRows);
            add = alreadyDeletdRows.indexOf(Integer.valueOf(selectedRow));
            alreadyDeletdRows.remove(Integer.valueOf(selectedRow));
          }
        } else { add = 0; }
        this.deletedRows.put(selectedRow + add, rows.get(selectedRow));
      }
      for (Object[] row : deletedRows.values()) { this.rows.remove(row); }

      for (int selectedRow : jTable1.getSelectedRows()) {
        this.fireTableRowsDeleted(selectedRow, selectedRow);
      }

      saveEnabled();
    }

    /** Cancel all changes in table */
    public void cancel() {
      int minRow = this.getRowCount(), maxRow = -1;
      for (Object[] newRow : newRows) {
        int i = rows.indexOf(newRow);
        if (minRow > i) { minRow = i; }
        if (maxRow < i) { maxRow = i; }
        this.rows.remove(newRow);
      }
      newRows.clear();
      this.fireTableRowsDeleted(minRow, maxRow);

      minRow = this.getRowCount();
      maxRow = -1;
      for (Map.Entry<Integer, Map<Integer, Object>> row : this.oldRows.entrySet()) {
        if (minRow > row.getKey()) { minRow = row.getKey(); }
        if (maxRow < row.getKey()) { maxRow = row.getKey(); }
        Object[] rVal = rows.get(row.getKey());
        for (Map.Entry<Integer, Object> cel : row.getValue().entrySet()) {
          rVal[cel.getKey()] = cel.getValue();
        }
      }
      oldRows.clear();
      this.fireTableRowsUpdated(minRow, maxRow);

      minRow = this.getRowCount();
      maxRow = -1;
      for (Map.Entry<Integer, Object[]> row : deletedRows.entrySet()) {
        if (minRow > row.getKey()) { minRow = row.getKey(); }
        if (maxRow < row.getKey()) { maxRow = row.getKey(); }
        this.rows.add(row.getKey(), row.getValue());
      }
      deletedRows.clear();
      this.fireTableRowsInserted(minRow, maxRow);

      saveEnabled();
    }

    @Override
    public Class<?> getColumnClass(int columnIndex) {
      Column col = td.getColumns().get(columnIndex);
      switch (col.getDataType()) {
        case STRING : return String.class;
        case INTEGER : return Integer.class;
        case DATE : return Date.class;
        default : return Object.class;
      }
    }

    @Override
    public int getRowCount() {
      return rows.size();
    }

    @Override
    public int getColumnCount() {
      if (rows.isEmpty()) { return 0; }
      return rows.get(0).length;
    }

    @Override
    public boolean isCellEditable(int rowIndex, int columnIndex) {
      Column col = td.getColumns().get(columnIndex);
      return !col.isGenerated();
    }

    @Override
    public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
      Object[] row = rows.get(rowIndex);
      if (!newRows.contains(row)) { // The new rows haven't any old value
        Map<Integer, Object> rowMap = oldRows.get(rowIndex);
        if (rowMap == null) {
          rowMap = new HashMap<>(td.getColumns().size());
          oldRows.put(rowIndex, rowMap);
        }
        if (!rowMap.containsKey(columnIndex)) { // Only first value is add to old value row (value from db)
          rowMap.put(columnIndex, row[columnIndex]);
        }
      }
      this.rows.get(rowIndex)[columnIndex] = aValue;

      Object oldValue = oldRows.get(rowIndex).get(columnIndex);
      if (AbstractHelper.nullEquals(oldValue, aValue)) {
        oldRows.get(rowIndex).remove(columnIndex);
        if (oldRows.get(rowIndex).isEmpty()) { oldRows.remove(rowIndex); }
      }
      saveEnabled();
    }

    /** Method which set save buton as enabled, or disabled, if there is something to save */
    private void saveEnabled() {
      bSave.setEnabled(!oldRows.isEmpty() || !newRows.isEmpty() || !deletedRows.isEmpty());
    }

    @Override
    public Object getValueAt(int rowIndex, int columnIndex) {
      return rows.get(rowIndex)[columnIndex];
    }
  }

  class CustomRenderer extends DefaultTableCellRenderer {

    private final TableDescription td;

    public CustomRenderer(TableDescription td) {
      this.td = td;
    }

    public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
      Component c = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
      Column col = td.getColumns().get(column);
      if (col.isAutoincrement()) {
        c.setForeground(new Color(133, 133, 133));
      }
      return c;
    }

  }

}
